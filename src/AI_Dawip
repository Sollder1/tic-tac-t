//default settings
let randomized: boolean = true
let AI_begins:boolean = true




/*  Node formt: explanation

grid format: filled with -1 or 1 if 
       0 | 1 | 2
       3 | 4 | 5
       6 | 7 | 8
   example: grid = [0, -1, 0, 1, 1, 0, -1, 0, 0]

player: the player how made the move that lead to this position
   AI = 1 = "O" , user = -1 = "X"

move:  the move that lead to this position (given as the grid position)

winner:
for leafs: return from has_won function
   0 or -1 or 1     
*/


////////////////////////////////////////////////////////////////////////// Node Class


export class Node {
    grid: number[]
    player: number
    move: number
    winner: number
    children: Node[] = []



    constructor(grid: number[], player:number, move:number, winner:number, children: Node[]) {
        this.grid = grid
        this.player = player
        this.move = move
        this.winner = winner
        this.children = children
    }


////////////////////////////////////////////////////////////////////////// helper functions


    public static toLinearArray(field: number[][]): number[] {
        let linearArray: number[] = [];
        let linearIndex = 0;

        for (let i: number = 0; i < field.length; i++) {
            for (let j: number = 0; j < field.length; j++) {
                linearArray[linearIndex] = field[i][j];
                linearIndex++;
            }
        }
        return linearArray;
    }


    public has_won(grid: number[]): number {
        let evaluation: number[] = [(grid[0] + grid[1] + grid[2]), (grid[3] + grid[4] + grid[5]), (grid[6] + grid[7] + grid[8]),
                                    (grid[0] + grid[3] + grid[6]), (grid[1] + grid[4] + grid[7]), (grid[2] + grid[5] + grid[8]),
                                    (grid[0] + grid[4] + grid[8]), (grid[6] + grid[4] + grid[2])]
        for (let i: number = 0; i < grid.length; i++) {
            if (grid[i] === -3) {
                return -1}
            else if (grid[i] === 3) {
                return 1}
        return 0
        }
    }


    public build_Node(grid: number[], player: number, i: number): Node {
        let new_grid:number[] = JSON.parse(JSON.stringify(grid))
        new_grid[i] = player
        return new Node(this.grid = new_grid, this.player = -player, this.move = i, this.winner = this.has_won(new_grid), this.children = [])
    }


////////////////////////////////////////////////////////////////////////// AI logic


    public build_tree() {
        if (this.winner === 0) {
            for (const i in [0,1,2,3,4,5,6,7,8]) {
                if (this.grid[i] === 0) {       //only continues the tree if game is not finished
                    this.children.push(this.build_Node(this.grid, this.player, i))
                }
            }
            let children_winner:number[] = [-2]     //evaluation
            for (let i = 0; i < this.children.length; i++){
                this.children[i].build_tree()
                children_winner.push(this.children[i].winner * this.player)        //evaluation
                this.winner = Math.max(...children_winner) * this.player   //evaluation
            }
        }
        else {return}
    }

    public node_search() {
        let value:number = -2
        let current_child:number = 0
        for (let i = 0; i < this.children.length; i++){
            if (randomized) {
                if ((this.children[i].winner > value) || ((this.children[i].winner === value) && (Math.random() > 0.66 ))) {
                    value = this.children[i].winner
                    current_child = i
                }
            }
            else {
                if (this.children[i].winner > value) {
                    value = this.children[i].winner
                    current_child = i
                }
            }
        }
        if (this.children[current_child].children === []) {
            if (this.children[current_child].winner === 0) {
                this.children[current_child].draw()
            }
            else {
                this.children[current_child].looser()
            }
        }
        else{
            this.children[current_child].input_output()
        }
    }

////////////////////////////////////////////////////////////////////////// IO



    

}
